Cytron et al
    semipruned SSA form


cfg.edges: Vec<(u32, u32)>; //[(0, 1), (0, 3), (1, 2), (2, 4), (3, 2)]
    [].0 = src block
    [].1 = dst block
    mapping of where every block jumps to

cfg.leader_set: Vec<(Instruction, usize)>,
    Contains the first instruction of all blocks + its index in the instr array

dom_tree: Vec<(isize, isize)>   (immediate dominator tree)
    contains the immediate dominator for a given node
    The first node does not have one

dom_set:  Vec<BTreeSet<isize>>
    contains a set of all dominators for a given node
    All nodes dominate themselves in this case, so the dominator for the first node is itself

df_list: Vec<BTreeSet<isize>>
    Dominance frontier of a given block

(TODO remove this because its basically just a useless duplicate of var_origin)
var_list:
    List of all variables declared in the program. Can contain duplicates.

var_origin:
    List of all variables alongside their index in the instruction array declared in the program.
    Can contain duplicates.

var_list_origin:
    Each vector-index represents a block, and contains a vector of all the register declarations
    within that block.

var_tuple:
    List of all registers alongside the block they were declared in.

def_sites
    block in which each register is defined

rename:
    rename() {
        for var in all_vars {
            // setup stack and count for them
        }
        rename_block(block)
    }

    NewName(n) {
        i = count[a]
        count[reg_def] += 1;
        stack.push[i];
        return changed_instr;
    }

    rename_block(basic_block) {

        for phi_functionin basic_block {
            let def = phi_function.o_reg().unwrap();
            NewName(def);
        }

        for instr in basic_block {
            for reg_use in instr {
                NewName(top(Stack[reg_use]))
            }
            for reg_def in instr {
                NewName(top(Stack[reg_def]))
            }
            for succ in basic_block {
                rename_block(succ);
            }
            for instr in block {
                if instr == phi {
                    pop(stack[instr.o_reg])
                }
            }

        }
    }
