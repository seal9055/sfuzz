Cytron et al
    semipruned SSA form


cfg.edges: Vec<(u32, u32)>; //[(0, 1), (0, 3), (1, 2), (2, 4), (3, 2)]
    [].0 = src block
    [].1 = dst block
    mapping of where every block jumps to

cfg.leader_set: Vec<(Instruction, usize)>,
    Contains the first instruction of all blocks + its index in the instr array

dom_tree: Vec<(isize, isize)>   (immediate dominator tree)
    contains the immediate dominator for a given node
    The first node does not have one

dom_set:  Vec<BTreeSet<isize>>
    contains a set of all dominators for a given node
    All nodes dominate themselves in this case, so the dominator for the first node is itself

df_list: Vec<BTreeSet<isize>>
    Dominance frontier of a given block

(TODO remove this because its basically just a useless duplicate of var_origin)
var_list:
    List of all variables declared in the program. Can contain duplicates.

var_origin:
    List of all variables alongside their index in the instruction array declared in the program.
    Can contain duplicates.

var_list_origin:
    Each vector-index represents a block, and contains a vector of all the register declarations
    within that block.

var_tuple:
    List of all registers alongside the block they were declared in.

def_sites
    block in which each register is defined

live-in
    register is alive before/during the block

live-out
    register is alive after the block
