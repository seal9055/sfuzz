Cytron et al
    semipruned SSA form


cfg.edges: Vec<(u32, u32)>; //[(0, 1), (0, 3), (1, 2), (2, 4), (3, 2)]
    [].0 = src block
    [].1 = dst block
    mapping of where every block jumps to

cfg.leader_set: Vec<(Instruction, usize)>,
    Contains the first instruction of all blocks + its index in the instr array

dom_tree: Vec<(isize, isize)>   (immediate dominator tree)
    contains the immediate dominator for a given node
    The first node does not have one

dom_set:  Vec<BTreeSet<isize>>
    contains a set of all dominators for a given node
    All nodes dominate themselves in this case, so the dominator for the first node is itself

df_list: Vec<BTreeSet<isize>>
    Dominance frontier of a given block

(TODO remove this because its basically just a useless duplicate of var_origin)
var_list:
    List of all variables declared in the program. Can contain duplicates.

var_origin:
    List of all variables alongside their index in the instruction array declared in the program.
    Can contain duplicates.

var_list_origin:
    Each vector-index represents a block, and contains a vector of all the register declarations
    within that block.

var_tuple:
    List of all registers alongside the block they were declared in.


rename:

    for var in all_vars {
        // setup stack and count for them
    }

    rename_block(basic_block) {

        for instr in basic_block {
            for reg_use in instr {
                i = top(Stack[reg_use]);
                // change instruction to use i for its use
            }

            for reg_def in instr {
                count[reg_def] += 1;
                i = count[a]
                stack.push[i];
                // change instruction to use i for its definition
            }
        }
    }
